# The display name of the workflow, which will appear in the GitHub Actions tab.
name: Unity Package CI

# This section defines the events that trigger the workflow to run.
on:
  # Run the workflow on pushes to the 'main' and 'develop' branches.
  push:
    branches: [ main, develop ]
  # Run the workflow on pull requests targeting the 'main' and 'develop' branches.
  pull_request:
    branches: [ main, develop ]
  
  # Allows the workflow to be run manually from the GitHub Actions UI.
  workflow_dispatch:

# A workflow is composed of one or more jobs that can run sequentially or in parallel.
jobs:
  # This job is responsible for running the Unity tests for the package.
  test:
    # The name of the job as it will appear in the GitHub UI.
    # The ${{ matrix.unity-version }} part will be replaced by the actual Unity version for each run.
    name: Run Unity Tests on ${{ matrix.unity-version }}
    # The type of virtual machine to run the job on. 'ubuntu-latest' is a standard choice for CI.
    runs-on: ubuntu-latest
    strategy:
      # 'fail-fast: false' ensures that if one test matrix job fails, the others will continue to run.
      # This is useful for testing against multiple Unity versions simultaneously.
      fail-fast: false
      # The 'matrix' strategy allows you to run the same job with different configurations.
      # Here, we define a list of Unity versions to test against.
      matrix:
        unity-version:
          - 2022.3.21f1  # The minimum supported LTS version for your package.
          - 2023.2.20f1  # The latest tech stream or LTS version for forward compatibility checks.
    
    steps:
      # Step 1: Checkout the repository code.
      # This action checks out your repository so the workflow can access your code.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          # 'lfs: true' is important if your project uses Git Large File Storage for big assets.
          lfs: true

      # Step 2: Cache the Unity Library folder.
      # This step significantly speeds up subsequent workflow runs by caching the imported assets.
      # The cache is invalidated if the Unity version or the project version file changes.
      - name: Cache Unity Library
        uses: actions/cache@v4
        with:
          path: TempProject/Library
          key: Library-${{ matrix.unity-version }}-${{ hashFiles('**/ProjectVersion.txt') }}
          restore-keys: |
            Library-${{ matrix.unity-version }}-

      # Step 3: Create a temporary Unity project to test the package in isolation.
      # This ensures that the tests are run in a clean environment without any external influences.
      - name: Create Unity Project Structure
        run: |
          echo "Setting up temporary Unity project..."
          mkdir -p TempProject/Assets
          mkdir -p TempProject/Packages
          mkdir -p TempProject/ProjectSettings
          
          # Use rsync to copy the package source code into the temporary project's Packages folder.
          # This simulates how Unity would handle a local package.
          rsync -r --exclude '.git' --exclude '.github' --exclude 'TempProject' . TempProject/Packages/com.fluxframework.core/
          
          # --- DYNAMIC MANIFEST GENERATION (THE KEY FIX) ---
          echo "Extracting dependencies from package.json..."
          # Install jq, a lightweight and powerful command-line JSON processor.
          sudo apt-get update && sudo apt-get install -y jq

          # Read the "dependencies" object from your package's actual package.json file.
          # Then, merge it with the base dependency which points to the local package file.
          # This ensures that ALL dependencies (including XR packages) are included in the test project.
          dependencies=$(jq -s '.[0].dependencies * .[1]' TempProject/Packages/com.fluxframework.core/package.json - <<EOF
          {
            "com.fluxframework.core": "file:com.fluxframework.core"
          }
          EOF
          )

          echo "Creating dynamic package manifest (manifest.json)..."
          # Create the manifest.json for the temporary project, injecting the dynamically generated dependencies.
          cat > TempProject/Packages/manifest.json << EOF
          {
            "dependencies": $dependencies,
            "testables": [
              "com.fluxframework.core"
            ]
          }
          EOF
          
          echo "Generated manifest.json content:"
          cat TempProject/Packages/manifest.json

          echo "Copying project settings from .ci folder..."
          # Copy predefined project settings to ensure a consistent test environment.
          cp .ci/ProjectSettings.asset TempProject/ProjectSettings/ProjectSettings.asset
          cp .ci/ProjectVersion.txt TempProject/ProjectSettings/ProjectVersion.txt

          echo "Setting project version to ${{ matrix.unity-version }}"
          # Dynamically update the editor version in the ProjectVersion.txt file to match the current matrix job.
          sed -i "s/m_EditorVersion:.*/m_EditorVersion: ${{ matrix.unity-version }}/" TempProject/ProjectSettings/ProjectVersion.txt

      # Step 4: Run the Unity tests using the GameCI Test Runner action.
      # This is the core step that executes your Unity tests in batch mode.
      - name: Run Unity Tests
        uses: game-ci/unity-test-runner@v4
        id: test-runner
        # Unity license credentials are passed as environment variables. These should be stored as GitHub secrets.
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}
        with:
          # The path to the temporary Unity project.
          projectPath: TempProject
          # The Unity version to use, taken from the matrix strategy.
          unityVersion: ${{ matrix.unity-version }}
          # Specifies which tests to run (e.g., editmode, playmode, or all).
          testMode: editmode
          # This tells the test runner to execute a specific static C# method to start the tests.
          customParameters: -executeMethod FluxFramework.Testing.FluxTestRunnerCli.RunTests

      # Step 5: Upload the test results as an artifact.
      # Artifacts are files that are saved after a workflow run has completed.
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        # 'if: always()' ensures this step runs even if the tests fail, so you can always access the logs.
        if: always()
        with:
          name: test-results-${{ matrix.unity-version }}
          path: ${{ steps.test-runner.outputs.artifactsPath }}
          retention-days: 7

  # This job validates the package structure to ensure it conforms to Unity's standards.
  package-validation:
    name: Package Validation
    runs-on: ubuntu-latest
    # This job will only start after the 'test' job has successfully completed.
    needs: test

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate Package Structure
        run: |
          echo "=== Validating Unity Package Structure ==="
          # Check for the existence of standard Unity package folders.
          [ -d "Runtime" ] || { echo "❌ Missing Runtime folder"; exit 1; }
          [ -d "Editor" ] || { echo "❌ Missing Editor folder"; exit 1; }
          [ -d "Testing" ] || { echo "❌ Missing Testing folder"; exit 1; }
          echo "✅ Required folders (Runtime, Editor, Testing) exist."

          [ -f "package.json" ] || { echo "❌ Missing package.json"; exit 1; }
          echo "✅ package.json exists."
          
          [ -f "Testing/FluxTestRunnerCli.cs" ] || { echo "❌ Missing Testing/FluxTestRunnerCli.cs"; exit 1; }
          echo "✅ Test runner script (FluxTestRunnerCli.cs) found."

          echo "✅ Package structure validation completed successfully."

      - name: Validate package.json
        run: |
          echo "=== Validating package.json ==="
          # Install jq to parse the JSON file.
          sudo apt-get update && sudo apt-get install -y jq
          # First, check if the JSON is valid.
          jq empty package.json || { echo "❌ Invalid JSON in package.json"; exit 1; }
          
          # Extract and display key information from the package manifest.
          name=$(jq -r '.name' package.json)
          version=$(jq -r '.version' package.json)
          unity=$(jq -r '.unity // "Not specified"' package.json)
          
          echo "- Package name: $name"
          echo "- Package version: $version"
          echo "- Unity version: $unity"
          
          # Perform specific checks, e.g., ensure the package name is correct.
          [ "$name" == "com.fluxframework.core" ] || { echo "❌ Expected package name 'com.fluxframework.core', got '$name'"; exit 1; }
          # Check for a critical dependency.
          jq -e '.dependencies["com.unity.nuget.newtonsoft-json"]' package.json > /dev/null || { echo "❌ Missing required dependency: com.unity.nuget.newtonsoft-json"; exit 1; }
          
          echo "✅ package.json validation completed successfully."

  # This job acts as a final gatekeeper before a potential release.
  publish-check:
    name: Publish Readiness Check
    runs-on: ubuntu-latest
    # This job requires both the 'test' and 'package-validation' jobs to pass.
    needs: [test, package-validation]
    # It only runs on pushes to the 'main' branch, simulating a pre-publish check.
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          # Fetch all history for all branches and tags.
          fetch-depth: 0

      - name: Log final check
        run: echo "✅ All tests and validation steps passed. The package is ready for publishing."