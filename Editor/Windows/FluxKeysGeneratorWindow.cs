using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Reflection;
using FluxFramework.Attributes;
using System.Linq;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;

namespace FluxFramework.Editor
{
    public class FluxKeysGeneratorWindow : EditorWindow
    {
        private const string GeneratedFilePath = "Assets/Flux/Generated/FluxKeys.cs";
        private List<string> _foundKeys = new List<string>();
        private Vector2 _scrollPosition;

        public static void ShowWindow()
        {
            GetWindow<FluxKeysGeneratorWindow>("Flux Keys Generator");
        }

        private void OnGUI()
        {
            EditorGUILayout.LabelField("Static Keys Generator", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("This tool scans the entire project for [ReactiveProperty] attributes and generates a static 'FluxKeys' class. This allows you to use type-safe constants (e.g., FluxKeys.PlayerHealth) instead of raw strings, preventing typos and enabling auto-completion.", MessageType.Info);

            if (GUILayout.Button("Scan Project and Generate Keys"))
            {
                ScanAndGenerate();
            }

            if (_foundKeys.Count > 0)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Keys Found:", EditorStyles.boldLabel);
                _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition, "box", GUILayout.ExpandHeight(true));
                foreach (var key in _foundKeys)
                {
                    EditorGUILayout.LabelField(key);
                }
                EditorGUILayout.EndScrollView();
            }
        }

        private void ScanAndGenerate()
        {
            // --- STEP 1: Scan the project to find all keys ---
            _foundKeys.Clear();
            var allMonoBehaviours = GetAllAssetsOfType<MonoBehaviour>();
            var allScriptableObjects = GetAllAssetsOfType<ScriptableObject>();
            var keySet = new HashSet<string>();

            foreach (var mb in allMonoBehaviours) FindKeysInObject(mb, keySet);
            foreach (var so in allScriptableObjects) FindKeysInObject(so, keySet);

            _foundKeys = keySet.OrderBy(k => k).ToList();

            if (_foundKeys.Count == 0)
            {
                EditorUtility.DisplayDialog("Scan Complete", "No [ReactiveProperty] attributes found in the project.", "OK");
                return;
            }

            // --- STEP 2: Generate the C# code ---
            string classContent = GenerateClassContent(_foundKeys);

            // --- STEP 3: Write the file to disk ---
            try
            {
                // Ensure the directory exists
                string directory = Path.GetDirectoryName(GeneratedFilePath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                File.WriteAllText(GeneratedFilePath, classContent);
                AssetDatabase.Refresh(); // Tell Unity to recompile
                EditorUtility.DisplayDialog("Success", $"Successfully generated '{GeneratedFilePath}' with {_foundKeys.Count} keys.", "OK");
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[FluxKeysGenerator] Failed to write file: {ex.Message}");
                EditorUtility.DisplayDialog("Error", $"Failed to write keys file. Check the console for details.", "OK");
            }
        }

        private void FindKeysInObject(object obj, HashSet<string> keySet)
        {
            if (obj == null) return;
            var fields = obj.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            foreach (var field in fields)
            {
                var reactiveAttr = field.GetCustomAttribute<ReactivePropertyAttribute>();
                if (reactiveAttr != null && !string.IsNullOrEmpty(reactiveAttr.Key))
                {
                    keySet.Add(reactiveAttr.Key);
                }
            }
        }

        private string GenerateClassContent(List<string> keys)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// --- AUTO-GENERATED FILE - DO NOT EDIT ---");
            sb.AppendLine("// This file is generated by the Flux Keys Generator. Any changes will be overwritten.");
            sb.AppendLine();
            sb.AppendLine("namespace Flux");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Contains static constants for all Reactive Property keys discovered in the project.");
            sb.AppendLine("    /// Use these constants in [FluxBinding] and other parts of the framework to avoid typos");
            sb.AppendLine("    /// and benefit from compile-time checking and auto-completion.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class FluxKeys");
            sb.AppendLine("    {");

            foreach (var key in keys)
            {
                string constantName = ConvertKeyToConstantName(key);
                sb.AppendLine($"        /// <summary> Original Key: \"{key}\" </summary>");
                sb.AppendLine($"        public const string {constantName} = \"{key}\";");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Converts a string key like "player.health" into a valid C# constant name like "PlayerHealth".
        /// </summary>
        private string ConvertKeyToConstantName(string key)
        {
            // Replace invalid characters with underscores
            string sanitized = Regex.Replace(key, @"[^a-zA-Z0-9_]", "_");
            
            // Convert to PascalCase (e.g., player_health -> PlayerHealth)
            return string.Concat(sanitized.Split('_')
                .Select(word => word.Length > 0 ? char.ToUpper(word[0]) + word.Substring(1) : ""));
        }

        private List<T> GetAllAssetsOfType<T>() where T : UnityEngine.Object
        {
            // This is the corrected version from our previous task
            var assets = new List<T>();
            string[] guids = AssetDatabase.FindAssets($"t:{typeof(T).Name}");

            foreach (string guid in guids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                UnityEngine.Object asset = AssetDatabase.LoadAssetAtPath(path, typeof(T));

                if (asset != null)
                {
                    if (asset is GameObject go)
                    {
                        if (typeof(Component).IsAssignableFrom(typeof(T)))
                        {
                            assets.AddRange(go.GetComponentsInChildren<T>(true));
                        }
                    }
                    else if (asset is T typedAsset)
                    {
                        assets.Add(typedAsset);
                    }
                }
            }
            
            if (typeof(Component).IsAssignableFrom(typeof(T)))
            {
                for (int i = 0; i < UnityEditor.SceneManagement.EditorSceneManager.sceneCount; i++)
                {
                    var scene = UnityEditor.SceneManagement.EditorSceneManager.GetSceneAt(i);
                    if (!scene.isLoaded) continue;
                    var rootObjects = scene.GetRootGameObjects();
                    foreach (var root in rootObjects)
                    {
                        assets.AddRange(root.GetComponentsInChildren<T>(true));
                    }
                }
            }
            return assets.Distinct().ToList();
        }
    }
}